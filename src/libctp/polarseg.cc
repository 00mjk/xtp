#include <votca/ctp/polarseg.h>
#include <boost/format.hpp>
#include <votca/ctp/dmaspace.h>


namespace votca { namespace ctp {

    
    
PolarSeg::PolarSeg(int id, vector<APolarSite*> &psites) : _id(id) {    
    for (int i = 0; i < psites.size(); ++i) {
        push_back(psites[i]);
    }
    this->CalcPos();
}


PolarSeg::PolarSeg(PolarSeg *templ) {
    // NOTE Polar neighbours _nbs are not copied !
    for (int i = 0; i < templ->_pfrags.size(); ++i) {
        PolarFrag *ref_frag = templ->_pfrags[i];
        PolarFrag *new_frag = this->AddFragment();
        for (PolarFrag::iterator pit = ref_frag->begin();
            pit != ref_frag->end(); ++pit) {
            APolarSite *new_site = new APolarSite(*pit);
            new_frag->push_back(new_site);
            this->push_back(new_site);
        }
    }
    this->_id = templ->_id;
    this->_pos = templ->_pos;
    this->_is_charged = templ->_is_charged;
    this->_is_polarizable = templ->_is_polarizable;
}
    
    
PolarSeg::~PolarSeg() {
   vector<APolarSite*> ::iterator pit;
   for (pit = begin(); pit < end(); ++pit) {         
       delete *pit;
   }
   clear();
   vector<PolarNb*>::iterator nit;
   for (nit = _nbs.begin(); nit < _nbs.end(); ++nit) 
       delete *nit;
   _nbs.clear();
}


void PolarSeg::AddPolarNb(PolarSeg *pseg) {
    PolarNb *new_nb = new PolarNb(pseg);
    _nbs.push_back(new_nb);
}


void PolarSeg::CalcPos() {    
    _pos = vec(0,0,0);    
    for (int i = 0; i < this->size(); ++i) {        
        _pos += (*this)[i]->getPos();        
    }
    if (this->size() > 0)
        _pos /= double(this->size());
}


double PolarSeg::CalcTotQ() {
    double Q = 0.0;
    for (int i = 0; i < this->size(); ++i) {
        Q += (*this)[i]->getQ00();
    }
    return Q;
}


void PolarSeg::Translate(const vec &shift) {    
    for (int i = 0; i < size(); ++i) {
        (*this)[i]->Translate(shift);
    }
    _pos += shift;
}


void PolarSeg::CalcIsCharged() {
    _is_charged = false;
    for (int i = 0; i < size(); ++i) {
        if ((*this)[i]->IsCharged()) _is_charged = true;
    }
    return;
}


void PolarSeg::CalcIsPolarizable() {
    _is_polarizable = false;
    for (int i = 0; i < size(); ++i) {
        if ((*this)[i]->IsPolarizable()) _is_polarizable = true;
    }
    return;
}


void PolarSeg::ClearPolarNbs() {
    vector<PolarNb*>::iterator nit;
    for (nit = _nbs.begin(); nit < _nbs.end(); ++nit) 
        delete *nit;
    _nbs.clear();
    return;
}


void PolarSeg::PrintPolarNbPDB(string outfile) {    
    FILE *out;
    out = fopen(outfile.c_str(),"w");
    PolarSeg::iterator pit;
    vector<PolarNb*>::iterator nit;
    for (pit = begin(); pit < end(); ++pit) {
        (*pit)->WritePdbLine(out, "CEN");
    }
    for (nit = _nbs.begin(); nit < _nbs.end(); ++nit) {
        PolarSeg *nb = (*nit)->getNb();
        nb->Translate((*nit)->getS());
        for (pit = nb->begin(); pit < nb->end(); ++pit) {
            (*pit)->WritePdbLine(out, "PNB");
        }
        nb->Translate(-1*(*nit)->getS());
    }
    fclose(out);
    return;
}


void PolarSeg::WriteMPS(string mpsfile, string tag) {    
    ofstream ofs;    
    ofs.open(mpsfile.c_str(), ofstream::out);
    if (!ofs.is_open()) {
        throw runtime_error("Bad file handle: " + mpsfile);
    }
    
    ofs << (boost::format("! GENERATED BY VOTCA::CTP::%1$s\n") % tag);
    ofs << (boost::format("! N=%2$d Q=%1$+1.7f\n")
        % CalcTotQ() % size());
    ofs << boost::format("Units angstrom\n");

    iterator pit;
    for (pit = begin(); pit < end(); ++pit) {
        (*pit)->WriteMpsLine(ofs, "angstrom");
    }    
    ofs.close();    
}


void PolarSeg::Coarsegrain() {
    // Reduce each polar fragment to a single polar site
    vector<APolarSite*> cg_sites;
    for (vector<PolarFrag*>::iterator fit = _pfrags.begin();
        fit < _pfrags.end(); ++fit) {
        // Position, state, rank, multipoles, polarizabilities
        vec pos = (*fit)->CalcPos();
        
        // Collapse multipole moments
        int state = 0;
        int L = 2;
        vector<double> QCG(L*L+2*L+1, 0.0);
        
        for (PolarFrag::iterator pit = (*fit)->begin();
            pit < (*fit)->end(); ++pit) {
            
//            vector<double> Qlm_vector = (*pit)->getQs(0);
//            DMA::ComplexSphericalMoments Xlm(Qlm_vector);
//            vector<DMA::cmplx> Xlm_vector = Xlm.ToVector();
//            DMA::RealSphericalMoments Qlm(Xlm_vector);
//            
//            cout << endl << "Converted from Qlm_vector:";
//            Xlm.PrintReal();
//            cout << endl << "Converted from Xlm_vector:";
//            Qlm.PrintReal();
            cout << endl << (*pit)->getName();
            // Convert real to complex moments            
            vector<double> Qlm = (*pit)->getQs(0);
            DMA::ComplexSphericalMoments Xlm(Qlm);
            cout << endl << "original";
            Xlm.PrintReal();
            // Shift moments
            DMA::MomentShift mshift;
            vec shift = vec(1,0,0); // = pos - (*pit)->getPos();
            DMA::RegularSphericalHarmonics Clm(-shift);            
            vector<DMA::cmplx> Xlm_shifted = mshift.Shift(Xlm, Clm);            
            // Convert complex to real moments & add to base
            DMA::RealSphericalMoments Qlm_shifted(Xlm_shifted);
            Qlm_shifted.AddToVector(QCG);
            cout << endl << "shifted";
            Qlm_shifted.PrintReal();
            
            // Shift back (Error check)
            vector<double> Qlm_shifted_vector = Qlm_shifted.ToVector();
            DMA::ComplexSphericalMoments Xlm_back(Qlm_shifted_vector);
            DMA::RegularSphericalHarmonics Clm_back(shift);
            vector<DMA::cmplx> Xlm_shifted_back = mshift.Shift(Xlm_back, Clm_back);
            DMA::RealSphericalMoments Qlm_back(Xlm_shifted_back);
            cout << endl << "restored";
            Qlm_back.PrintReal();
            
            
            int a; cin >> a;
        }
        // Collapse polarizabilities
        votca::tools::matrix PCG = votca::tools::matrix();
        
        // Generate new coarse-grained site from the above
        APolarSite *cg_site = new APolarSite((*fit)->getId(), "CG");
        cg_site->setPos(pos);
        cg_site->setRank(L);
        cg_site->setQs(QCG, state);
        cg_site->setPs(PCG, state);
        cg_site->Charge(state);
        cg_sites.push_back(cg_site);
        // Clear fragment & reload
        (*fit)->clear();
        (*fit)->push_back(cg_site);
    }
    // Clean up & reload
    assert(cg_sites.size() == _pfrags.size());
    vector<APolarSite*> ::iterator pit;
    for (pit = begin(); pit < end(); ++pit) delete *pit;
    clear();
    for (pit = cg_sites.begin(); pit < cg_sites.end(); ++pit) push_back(*pit);
    return;
}


}}