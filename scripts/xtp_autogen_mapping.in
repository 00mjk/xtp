#! /usr/bin/env python3
#
# Copyright 2009-2020 The VOTCA Development Team (http://www.votca.org)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

VERSION='@PROJECT_VERSION@ #CSG_GIT_ID#'

from rdkit import Chem
from xml.dom import minidom
import xml.etree.ElementTree as ET
import argparse
import os
import shutil

global orca_exec

# optimize geometry, get CHELPG charges, polarizability tensor
def optimize(state, name, functional='PBE0', basis='def2-tzvp', RI=True,nprocs=4):
    
    input_file_name = name+'_'+state+".inp"
    input_file = open(input_file_name,"w")
    # geometry optimization starts from MD structure for n, and n structure of e/h
    if state == 'n':
        crg_spin_coord = '* xyzfile 0 1 '+name+'_MD.xyz\n'
    if state == 'e':
        crg_spin_coord = ' * xyzfile -1 2 '+name+'_n.xyz\n'
    if state == 'h':
        crg_spin_coord = ' * xyzfile 1 2 '+name+'_n.xyz\n'
    input_file.write(crg_spin_coord)
    input_file.write('\n')

    input_file.write('%pal\n')
    input_file.write('nprocs '+str(nprocs)+'\n')
    input_file.write('end\n')
    input_file.write('\n')

    if RI:
        RI_string = ' RIJCOSX\n'
    else:
        RI_string = ' \n'
    input_file.write('! DFT opt '+str(functional)+' '+str(basis)+str(RI_string))
    input_file.write('! D3BJ\n')
    input_file.write('! CHELPG\n')
    input_file.write('\n')

    input_file.write('% elprop\n')
    input_file.write('polar 1\n')
    input_file.write('end\n')
    input_file.write('\n')
    input_file.close()

    # run orca
    logfile_name = name+'_'+state+".log"
    errfile_name = name+'_'+state+".err"
    orca_command = orca_exec+' '+input_file_name+' > '+logfile_name+' 2>'+errfile_name
    os.system(orca_command)

    # parse SINGLE POINT ENERGIES
    energies = []
    with open(logfile_name,'r') as logfile:
        for line in logfile.readlines():
            if 'FINAL SINGLE POINT ENERGY' in line:
                energies.append(float(line.split()[-1]))

    E_initial = energies[0]
    E_final = energies[-1]

    # copy optimized geometries
    if not os.path.exists('../QC_FILES'):
        os.makedirs('../QC_FILES')
    geofile = name+'_'+state+".xyz"
    geofile_store = '../QC_FILES/'+geofile
    shutil.copy(geofile, geofile_store)

    # parse CHELPG charges
    logfile_name = name+'_'+state+"_log2mps.log"
    errfile_name = name+'_'+state+"_log2mps.err"
    log2mps_command='xtp_tools -e log2mps -n '+name+'_'+state+' > '+logfile_name+' 2> '+errfile_name
    os.system(log2mps_command)

    # optimize polarizability
    logfile_name = name+'_'+state+"_log2mps.log"
    errfile_name = name+'_'+state+"_log2mps.err"
    # prep molpol.xml
    options = ET.Element('options')
    molpol = ET.SubElement(options,'molpol')
    mode = ET.SubElement(molpol,'mode')
    mode.text = 'qmpackage'
    logname = ET.SubElement(molpol,'logfile')
    logname.text = name+'_'+state+".log"
    molpol_xml_str = minidom.parseString(ET.tostring(options)).toprettyxml(indent="   ")
    with open("molpol.xml", "w") as f: 
        f.write(molpol_xml_str)  
    # run molpol
    molpol_command = 'xtp_tools -e molpol -o molpol.xml -n '+name+'_'+state+' > '+logfile_name+' 2> '+errfile_name
    os.system(molpol_command)
    # copy oprimized MPS_FILE
    if not os.path.exists('../MP_FILES'):
        os.makedirs('../MP_FILES')
    mpsfile = name+'_'+state+"_polar.mps"
    mpsfile_store = '../MP_FILES/'+mpsfile
    shutil.copy(mpsfile, mpsfile_store)

    E_n_X = 0.0

    # if state is h or e, calculate a single energy for the neural molecule in the optimized geometry
    if state != 'n':
        input_n_file_name = name+'_'+state+"_n.inp"
        input_n_file = open(input_n_file_name,"w")
        # geometry optimization starts from MD structure for n, and n structure of e/h
        if state == 'e':
            crg_spin_coord = ' * xyzfile 0 1 '+name+'_e.xyz\n'
        if state == 'h':
            crg_spin_coord = ' * xyzfile 0 1 '+name+'_h.xyz\n'
        input_n_file.write(crg_spin_coord)
        input_n_file.write('\n')

        input_n_file.write('%pal\n')
        input_n_file.write('nprocs '+str(nprocs)+'\n')
        input_n_file.write('end\n')
        input_n_file.write('\n')

        if RI:
            RI_string = ' RIJCOSX\n'
        else:
            RI_string = ' \n'
        input_n_file.write('! DFT '+str(functional)+' '+str(basis)+str(RI_string))
        input_n_file.write('! D3BJ\n')
        input_n_file.close()
        # run ORCA again
        logfile_n_name = name+'_'+state+"_n.log"
        errfile_n_name = name+'_'+state+"_n.err"
        orca_command = orca_exec+' '+input_n_file_name+' > '+logfile_n_name+' 2>'+errfile_n_name
        os.system(orca_command)

        # parse SINGLE POINT ENERGIES
        energies_n = []
        with open(logfile_n_name,'r') as logfile:
            for line in logfile.readlines():
                if 'FINAL SINGLE POINT ENERGY' in line:
                    energies_n.append(float(line.split()[-1]))

        E_n_X = energies_n[0]

    return E_initial, E_final, E_n_X



# Construct the argument parser
ap = argparse.ArgumentParser()

# Add the arguments to the parser
ap.add_argument("-pdb", "--pdbfile", required=True,
   help="PDB coordinate file")
ap.add_argument("-opt", "--optimize", type=int, default=0,
   help="optimization of XYZ and MPS files", choices=[0,1])
ap.add_argument("-s", "--states", default="n", nargs="+",
   help="which states to optimize", choices=["n","e","h"])
ap.add_argument("-orca", "--orca", default="/opt/orca-4.2.1/orca", 
   help="full path to orca executable")

args = vars(ap.parse_args())

pdb_file = args['pdbfile']
seg_name = os.path.splitext(pdb_file)[0]
do_optimize = bool(args['optimize'])
states = args['states']
orca_exec = args['orca']



# read the initial PDB file
mol = Chem.MolFromPDBFile(pdb_file,removeHs=False)


if do_optimize:
    if not os.path.exists('generate'):
        os.makedirs('generate')
    basedir=os.getcwd()
    os.chdir('generate')
    mdXYZ_file_name = seg_name+'_MD.xyz'
    Chem.MolToXYZFile(mol,mdXYZ_file_name)
    # neutral
    E_n_init, E_n_final, E_n_cross = optimize(state='n',name=seg_name,functional='PBE0',basis='def2-tzvp',RI=True, nprocs=4)
    # cation, if requested
    if 'h' in states:
        E_h_init, E_h_final, E_h_cross = optimize(state='h',name=seg_name,functional='PBE0',basis='def2-tzvp',RI=True, nprocs=4)
    # anion, if requested
    if 'e' in states:
        E_e_init, E_e_final, E_e_cross = optimize(state='e',name=seg_name,functional='PBE0',basis='def2-tzvp',RI=True, nprocs=4)
    os.chdir(basedir)





# determine the rotatable bonds
RotatableBond = Chem.MolFromSmarts('[!$(*#*)&!D1]-&!@[!$(*#*)&!D1]')
rbonds=mol.GetSubstructMatches(RotatableBond)
bs = [mol.GetBondBetweenAtoms(x,y).GetIdx() for x,y in rbonds]
mol1 = Chem.Mol(mol)

fragments = []
# fragment molecule based on the rotatable bonds
if bs == []:
    fragments.append(mol1)
else:
    new_mol = Chem.FragmentOnBonds(mol1, bs)
    fragments = Chem.GetMolFrags(new_mol,asMols=True)

# generating the XML tree
topology = ET.Element('topology')
molecules = ET.SubElement(topology,'molecules')
molecule = ET.SubElement(molecules,'molecule')
name = ET.SubElement(molecule,'name')
name.text = seg_name
mdname = ET.SubElement(molecule,'mdname')
mdname.text = seg_name
segments = ET.SubElement(molecule,'segments')
segment = ET.SubElement(segments,'segment')
segment_name = ET.SubElement(segment,'name')
segment_name.text = seg_name
segment_coord_n = ET.SubElement(segment,'qmcoords_n')
segment_coord_n.text = 'QC_FILES/'+seg_name+"_n.xyz"
segment_mpoles_n = ET.SubElement(segment,'multipoles_n')
segment_mpoles_n.text = 'MP_FILES/'+seg_name+"_n_polar.mps"
if 'h' in states:
    segment_coord_h = ET.SubElement(segment,'qmcoords_h')
    segment_coord_h.text = 'QC_FILES/'+seg_name+"_h.xyz"
    segment_mpoles_h = ET.SubElement(segment,'multipoles_h')
    segment_mpoles_h.text = 'MP_FILES/'+seg_name+"_h_polar.mps"
    segment_U_xX_nN_h = ET.SubElement(segment,'U_xX_nN_h') # adiabatic excitation energy
    U_xX_nN_h = 27.21138*(E_h_final - E_n_final)
    segment_U_xX_nN_h.text = str(U_xX_nN_h)
    segment_U_nX_nN_h = ET.SubElement(segment,'U_nX_nN_h') # reorg energy deexcitation
    U_nX_nN_h = 27.21138*(E_h_cross - E_n_final)
    segment_U_nX_nN_h.text = str(U_nX_nN_h)
    segment_U_xN_xX_h = ET.SubElement(segment,'U_xN_xX_h') # reorg energy excitation
    U_xN_xX_h = 27.21138*(E_h_init - E_h_final)
    segment_U_xN_xX_h.text = str(U_xN_xX_h)
if 'e' in states:
    segment_coord_e = ET.SubElement(segment,'qmcoords_e')
    segment_coord_e.text = 'QC_FILES/'+seg_name+"_e.xyz"
    segment_mpoles_e = ET.SubElement(segment,'multipoles_e')
    segment_mpoles_e.text = 'MP_FILES/'+seg_name+"_e_polar.mps"
    segment_U_xX_nN_e = ET.SubElement(segment,'U_xX_nN_e') # adiabatic excitation energy
    U_xX_nN_e = 27.21138*(E_e_final - E_n_final)
    segment_U_xX_nN_e.text = str(U_xX_nN_e)
    segment_U_nX_nN_e = ET.SubElement(segment,'U_nX_nN_e') # reorg energy deexcitation
    U_nX_nN_e = 27.21138*(E_e_cross - E_n_final)
    segment_U_nX_nN_e.text = str(U_nX_nN_e)
    segment_U_xN_xX_e = ET.SubElement(segment,'U_xN_xX_e') # reorg energy excitation
    U_xN_xX_e = 27.21138*(E_e_init - E_e_final)
    segment_U_xN_xX_e.text = str(U_xN_xX_e)

map2md = ET.SubElement(segment,'map2md')
map2md.text = '0'

xmlfragments = ET.SubElement(segment,'fragments')


# Go through all fragments
i=0
for fragment in fragments:
    i=i+1
    filename="fragment"+str(i)+".pdb"
    Chem.MolToPDBFile(fragment, filename)
    conf=fragment.GetConformer()
    
    xmlfragment = ET.SubElement(xmlfragments, 'fragment')
    frag_name = ET.SubElement(xmlfragment,'name')
    frag_name.text = 'fragment'+str(i)
    mdatoms = ET.SubElement(xmlfragment,'mdatoms')
    qmatoms = ET.SubElement(xmlfragment,'qmatoms')
    mpoles = ET.SubElement(xmlfragment,'mpoles')
    weights = ET.SubElement(xmlfragment,'weights')
    localframe = ET.SubElement(xmlfragment,'localframe')
    
    mdatoms_str = ""
    qmatoms_str = ""
    weights_str = ""
    for atom in range(0,fragment.GetNumAtoms()):
        this_element = fragment.GetAtoms()[atom].GetSymbol()
        if this_element != "*":
            this_pos = conf.GetAtomPosition(atom)
            for full_atom in range(0,mol.GetNumAtoms()):
                full_element = mol.GetAtoms()[full_atom].GetSymbol()
                full_atomtype = mol.GetAtoms()[full_atom].GetPDBResidueInfo().GetName().replace(" ","")
                full_pos = mol.GetConformer().GetAtomPosition(full_atom)
                if full_pos.x == this_pos.x:
                    if full_pos.y == this_pos.y:
                        if full_pos.z == this_pos.z:
                            mdatoms_str += "0:"+str(full_atomtype)+":"+str(full_atom)+" "
                            qmatoms_str += str(full_atom)+":"+str(full_element)+" "
                            weights_str += str(mol.GetAtoms()[full_atom].GetMass())+" "
    mdatoms.text = mdatoms_str
    qmatoms.text = qmatoms_str
    mpoles.text = qmatoms_str
    weights.text = weights_str
    
xml_str = minidom.parseString(ET.tostring(topology)).toprettyxml(indent="   ")
with open("mapping.xml", "w") as f: 
    f.write(xml_str)  
