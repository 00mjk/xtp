/*
 * Copyright 2009-2011 The VOTCA Development Team (http://www.votca.org)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#ifndef __VOTCA_CTP_FRAGMENT_H
#define	__VOTCA_CTP_FRAGMENT_H

#include <votca/ctp/atom.h>



namespace votca { namespace ctp {

class Topology;
class Molecule;
class Segment;
    
/**
    \brief Rigid fragment. One conjugated segment contains several rigid fragments.

 * Apart from the position and orientation it has a pointer to a conjugated segment 
 * it belongs to as well as positions of atoms which belong to it of two types those 
 * which are generated by MD and those obtained by substitution of rigid copies
 */

class Fragment {
public:
     /// Constructor
     Fragment(int id, string name)
     {
         _id = id; _name = name; _symmetry = 0;
     }
     /// Destructor
    ~Fragment()
    {
        vector < Atom* > ::iterator atmit;
        for (atmit = this->Atoms().begin();
                atmit < this->Atoms().end();
                atmit++) {
            delete *atmit;
        }
        _weights.clear();
        _atoms.clear();
    }
   /**
     * get the id of the segment
     * \return bead id
     */
    const int &getId() const { return _id; }
     /**
     * get the id of the segment
     * \return bead id
     */
    const string getName() const { return _name; }

    void AddAtom( Atom* atom ) {
        _atoms.push_back( atom );
        atom->setFragment(this);
        _weights.push_back( atom->getWeight() );
    }
    vector< Atom* > &Atoms() { return _atoms; }
    int NumberOfAtoms() { return _atoms.size(); }

    /// Rotates the fragment with respect to the center defined by the Map
    void Rotate (){ 
        throw runtime_error( string("Not implemented") ); 
    }
    /// Translates the fragment by a specified vector
    void Translate(){ 
        throw runtime_error( string("Not implemented") ); 
    }
    
    inline void setTopology(Topology *container) { _top = container; }
    inline void setMolecule(Molecule *container) { _mol = container; }
    inline void setSegment(Segment *container)   { _seg = container; }

    Topology *getTopology() { return _top; }
    Molecule *getMolecule() { return _mol; }
    Segment  *getSegment()  { return _seg; }

    void    setSymmetry(int symmetry) { _symmetry = symmetry; }
    int     getSymmetry() { return _symmetry; }

    
private:

    Topology    *_top;
    Molecule    *_mol;
    Segment     *_seg;

    vector < Atom* > _atoms;
    vector< double > _weights;

    string      _name;
    int         _id;

    int         _symmetry;


};

}}

#endif	/* __VOTCA_CTP_FRAGMENT_H */

